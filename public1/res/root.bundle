{
  "92aca09436674360863731d38f23827a.material": {
    "texturesMapping": {},
    "flat": false,
    "cullState": {
      "frontFace": "CCW",
      "enabled": true,
      "cullFace": "Back"
    },
    "uniforms": {
      "opacity": {
        "enabled": false,
        "value": 1
      },
      "refractivity": {
        "enabled": false,
        "value": 0
      },
      "materialAmbient": {
        "enabled": true,
        "value": [
          0.1,
          0.1,
          0.1,
          1
        ]
      },
      "materialSpecular": {
        "enabled": true,
        "value": [
          0.6,
          0.6,
          0.6,
          1
        ]
      },
      "fresnel": {
        "enabled": true,
        "value": 0.5
      },
      "vertexColorAmount": {
        "enabled": true,
        "value": 1
      },
      "materialSpecularPower": {
        "enabled": true,
        "value": 64
      },
      "materialDiffuse": {
        "enabled": true,
        "value": [
          0.8,
          0.8,
          0.8,
          1
        ]
      },
      "reflectivity": {
        "enabled": true,
        "value": 0.6
      },
      "materialEmissive": {
        "enabled": true,
        "value": [
          0,
          0,
          0,
          1
        ]
      },
      "discardThreshold": {
        "enabled": true,
        "value": 0.1
      },
      "normalMultiplier": {
        "enabled": true,
        "value": 1
      },
      "etaRatio": {
        "enabled": true,
        "value": -0.5
      },
      "reflectionType": 0,
      "wrapSettings": {
        "enabled": true,
        "value": [
          0,
          0
        ]
      }
    },
    "name": "Default Material 2",
    "license": "CC0",
    "created": "2016-02-22T14:26:02.844Z",
    "deleted": false,
    "wireframe": false,
    "dataModelVersion": 2,
    "blendState": {
      "blendEquation": "AddEquation",
      "blendSrc": "SrcAlphaFactor",
      "blendDst": "OneMinusSrcAlphaFactor",
      "blending": "NoBlending"
    },
    "modified": "2016-02-22T14:26:02.844Z",
    "dualTransparency": false,
    "depthState": {
      "write": true,
      "enabled": true
    },
    "shaderRef": "GOO_ENGINE_SHADERS/uber",
    "id": "92aca09436674360863731d38f23827a.material",
    "renderQueue": -1
  },
  "4d2303a5ad484fea930530132d84ff03.entity": {
    "name": "Sphere",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2016-02-26T15:46:13.823Z",
    "dataModelVersion": 2,
    "modified": "2016-02-26T15:46:13.823Z",
    "static": false,
    "components": {
      "meshData": {
        "shape": "Sphere",
        "shapeOptions": {
          "radialSamples": 32,
          "textureMode": "Projected",
          "radius": 0.5,
          "zSamples": 24
        }
      },
      "transform": {
        "rotation": [
          -90,
          0,
          0
        ],
        "scale": [
          100,
          100,
          100
        ],
        "translation": [
          0,
          0,
          0
        ]
      },
      "meshRenderer": {
        "receiveShadows": true,
        "materials": {
          "4cfc09f9b76a4f4cad4a6032cdf0744a.material": {
            "materialRef": "4cfc09f9b76a4f4cad4a6032cdf0744a.material",
            "sortValue": 0
          }
        },
        "reflectable": true,
        "cullMode": "Dynamic",
        "castShadows": true
      },
      "script": {
        "scripts": {
          "1d99cc5178db4c6abb9907cdac38c730.scriptinstance": {
            "id": "1d99cc5178db4c6abb9907cdac38c730.scriptinstance",
            "name": "Instance of Stream video script",
            "scriptRef": "f262bb7418044b34ae6100230b7988c4.script",
            "sortValue": 0,
            "options": {
              "enabled": true,
              "videoTexture": {
                "enabled": true,
                "textureRef": "679f7c69547246e5a03cf501af127572.texture"
              },
              "videoUrl": "res/run.mp4"
            }
          }
        }
      }
    },
    "hidden": true,
    "id": "4d2303a5ad484fea930530132d84ff03.entity"
  },
  "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity": {
    "name": "Default Camera",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2015-07-27T15:45:29.148Z",
    "dataModelVersion": 2,
    "modified": "2015-07-27T15:45:29.148Z",
    "static": false,
    "components": {
      "camera": {
        "fov": 45,
        "lockedRatio": false,
        "far": 1000,
        "followEditorCam": false,
        "projectionMode": "Perspective",
        "near": 1,
        "aspect": 1,
        "size": 5
      },
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          0,
          0,
          0
        ]
      },
      "script": {
        "scripts": {
          "83a93026ad294009a907e314e461eed3.scriptInstance": {
            "scriptRef": "GOO_ENGINE_SCRIPTS/OrbitNPanControlScript",
            "options": {
              "maxAscent": 89.95,
              "whenUsed": true,
              "orbitSpeed": 0.005,
              "clampAzimuth": false,
              "maxAzimuth": 270,
              "minZoomDistance": 1,
              "enabled": true,
              "minAzimuth": 90,
              "minAscent": -89,
              "lookAtDistance": 1,
              "drag": 0.9,
              "dragButton": "Left",
              "panButton": "Right",
              "zoomSpeed": 1,
              "smoothness": 0.4,
              "maxZoomDistance": 1000
            },
            "id": "83a93026ad294009a907e314e461eed3.scriptInstance",
            "sortValue": 0,
            "name": "OrbitNPan"
          }
        }
      }
    },
    "hidden": false,
    "id": "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity"
  },
  "72b440a4a1fd4493ba4f8d77b1399e4d.script": {
    "body": "var setup = function(args, ctx, goo) {\n\t// Parse background color\n\tvar backgroundColor = [\n\t\tMath.floor(args.backgroundColor[0] * 255),\t\n\t\tMath.floor(args.backgroundColor[1] * 255),\t\n\t\tMath.floor(args.backgroundColor[2] * 255),\t\n\t];\n\t\n\t// Store stuff\n\tvar mrc = ctx.entity.meshRendererComponent;\n\tif (!mrc) { return; }\n\tctx.mat = mrc.materials[0];\n\tctx.oldTexture = ctx.mat.getTexture('DIFFUSE_MAP');\n\t\n\t// Scale for aspect ratio\n\tvar scale = ctx.entity.getScale().data;\n\tctx.ratio = scale[0] / scale[1];\n\t\n\t// Calculate texture size depending on ratio\n\tctx.size = [args.texSize, args.texSize];\n\tvar pot;\n\tif (ctx.ratio > 2) {\n\t\tpot = goo.MathUtils.nearestHigherPowerOfTwo(ctx.ratio);\n\t\tpot = Math.min(pot, 4096);\n\t\tctx.size[0] *= pot / 2;\n\t\tctx.ratio /= (pot / 2);\n\t} else if (ctx.ratio < 0.5) {\n\t\tpot = goo.MathUtils.nearestHigherPowerOfTwo(1 / ctx.ratio);\n\t\tpot = Math.min(pot, 4096);\n\t\tctx.size[1] *= pot / 2;\n\t\tctx.ratio *= (pot / 2);\n\t}\n\n\t// Create the canvas texture\n\tctx.texture = createTexture(goo, ctx.size[0], ctx.size[1], ctx.ratio);\n\tctx.texture.setStyle({\n\t\ttextAlign: args.textAlign,\n\t\tverticalAlign: args.verticalAlign,\n\t\tlineHeight: args.lineHeight,\n\t\tfont: args.font,\n\t\tmargin: args.margin,\n\t\tbackground: (args.transparent ? 'transparent' : backgroundColor),\n\t\twordWrap: args.wordWrap\n\t});\n\tctx.texture.setText(args.text);\n\n\tctx.bus = function(data) {\n\t\tif (data.entity === ctx.entity) {\n\t\t\tctx.texture.setText(data.text);\n\t\t}\n\t}\n\tgoo.SystemBus.addListener('quadtext.setText', ctx.bus);\n\tctx.mat.setTexture('DIFFUSE_MAP', ctx.texture);\n};\nvar cleanup = function(args, ctx, goo) {\n\t// Restore old texture\n\tgoo.SystemBus.removeListener('quadtext.setText', ctx.bus);\n\tctx.mat.setTexture('DIFFUSE_MAP', ctx.oldTexture);\n\tif (ctx.texture && ctx.texture.glTexture) {\n\t\tctx.texture.destroy(ctx.world.gooRunner.renderer.context);\n\t}\n};\n\nvar parameters = [{\n\tkey: 'text',\n\ttype: 'string',\n\t'default': 'Hello world!'\n}, {\n\tkey: 'transparent',\n\ttype: 'boolean',\n\t'default': true\n}, {\n\tkey: 'wordWrap',\n\ttype: 'boolean',\n\t'default': true\n}, {\n\tkey: 'backgroundColor',\n\ttype: 'vec3',\n\tcontrol: 'color',\n\t'default': [0,0,0]\n}, {\n\tkey: 'textAlign',\n\ttype: 'string',\n\tcontrol: 'select',\n\toptions: ['left', 'center', 'right'],\n\t'default': 'center'\n}, {\n\tkey: 'verticalAlign',\n\ttype: 'string',\n\tcontrol: 'select',\n\toptions: ['top', 'middle', 'bottom'],\n\t'default': 'middle'\n}, {\n\tkey: 'font',\n\ttype: 'string',\n\tcontrol: 'select',\n\toptions: ['Roboto', 'Helvetica', 'Times'],\n\t'default': 'Roboto'\n}, {\n\tkey: 'margin',\n\ttype: 'int',\n\tmin: 0,\n\t'default': 0\n}, {\n\tkey: 'lineHeight',\n\ttype: 'float',\n\tmin: 0.1,\n\t'default': 1.3\n}, {\n\tkey: 'texSize',\n\ttype: 'float',\n\tcontrol: 'select',\n\toptions: [128, 256, 512, 1024, 2048],\n\t'default': 512\n}];\n\n\nfunction createTexture(goo, width, height, ratio) {\n\tvar canvas = document.createElement('canvas')\n\tcanvas.width = width;\n\tcanvas.height = height;\n\tvar context = canvas.getContext('2d');\n\tvar totalMaxHeight = height / ratio;\n\t\n\t// Modifyables\n\tvar style = {\n\t\ttextAlign: 'left',\n\t\tverticalAlign: 'bottom',\n\t\tlineHeight: 1.3,\n\t\tfont: 'Roboto',\n\t\tmargin: 0,\n\t\tbackground: 'transparent',\n\t\twordWrap: true\n\t};\n\tvar text = {\n\t\tvalue: 'Hello world'\n\t};\n\tvar fontSize = 20;\n\t\n\t// Texture;\n\tvar tex = new goo.Texture(canvas);\n\ttex.setStyle = function(obj) {\n\t\tfor (var key in style) {\n\t\t\tif (obj[key] !== undefined) {\n\t\t\t\tstyle[key] = obj[key];\n\t\t\t}\n\t\t}\n\t\tthis._update();\n\t};\n\ttex.setText = function (str) {\n\t\ttext.value = str;\n\t\tthis._update();\n\t};\n\ttex._update = function () {\n\t\tthis._updateStyle();\n\t\tthis._printText();\n\t\tthis.setNeedsUpdate();\n\t}\n\ttex._clear = function() {\n\t\tif (style.background === 'transparent') {\n\t\t\tcontext.clearRect(0, 0, width, totalMaxHeight);\n\t\t} else {\n\t\t\tcontext.fillStyle = 'rgb(' + style.background.join(',') + ')';\n\t\t\tcontext.rect(0, 0, width, totalMaxHeight);\n\t\t\tcontext.fill();\n\t\t\tcontext.fillStyle = '#FFF';\n\t\t}\n\t}\n\ttex._updateStyle = function() {\n\t\t// Fixed\n\t\tcontext.fillStyle = '#FFF';\n\t\tcontext.textBaseline = 'bottom';\n\t\t\n\t\t//Custom\n\t\tcontext.textAlign = style.textAlign;\n\t\tcontext.font = fontSize + 'px ' + style.font;\n\t};\n\ttex._printText = function () {\n\t\tthis._updateStyle();\n\t\tcontext.save();\n\t\tcontext.scale(1, ratio);\n\n\t\tvar maxWidth = width - style.margin * 2;\n\t\tvar maxHeight = totalMaxHeight - style.margin * 2;\n\t\tvar lineHeight = style.lineHeight * fontSize;\n\n\t\tif (!style.wordWrap) {\n\t\t\tvar lineWidth = context.measureText(text.value).width;\n\t\t\tfontSize *= Math.min (maxWidth / lineWidth, maxHeight / lineHeight);\n\t\t\tlineHeight = style.lineHeight * fontSize;\n\t\t\tcontext.font = fontSize + 'px ' + style.font;\n\t\t\tvar x, y;\n\t\t\tif (style.verticalAlign === 'top') { y = lineHeight + style.margin; } \n\t\t\telse if (style.verticalAlign === 'middle') { y = (totalMaxHeight + lineHeight) / 2; }\n\t\t\telse if (style.verticalAlign === 'bottom') { y = totalMaxHeight - style.margin; }\n\t\t\tif (style.textAlign === 'left') { x = style.margin; }\n\t\t\telse if (style.textAlign === 'center') { x = width / 2; }\n\t\t\telse if (style.textAlign === 'right') { x = width - style.margin; }\n\t\t\tthis._clear();\n\t\t\tcontext.fillText(text.value, x, y);\n\t\t} else {\n\t\t\tvar size = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t\tvar offset = {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t}\n\t\t\tvar iterations = 0;\n\t\t\twhile (iterations < 100 && (\n\t\t\t\tsize.height > maxHeight || \n\t\t\t\tsize.height < maxHeight - lineHeight ||\n\t\t\t\tsize.width > maxWidth\n\t\t\t)) {\n\t\t\t\tif (size.width > maxWidth) {\n\t\t\t\t\tfontSize *= maxWidth / size.width;\n\t\t\t\t\tcontext.font = fontSize + 'px ' + style.font;\n\t\t\t\t} else if (size.height > 0) {\n\t\t\t\t\t// Update font size to fill\n\t\t\t\t\tfontSize *= 1 + (1 - maxHeight / size.height) * -0.1;\n\t\t\t\t\tcontext.font = fontSize + 'px ' + style.font;\n\t\t\t\t}\n\t\t\t\tlineHeight = style.lineHeight * fontSize;\n\t\t\t\tif (style.textAlign === 'left') { offset.x = style.margin; }\n\t\t\t\telse if (style.textAlign === 'center') { offset.x = width / 2; }\n\t\t\t\telse if (style.textAlign === 'right') { offset.x = width - style.margin; }\n\t\t\t\tthis._wrapText(size, offset, false);\n\t\t\t\t\n\t\t\t\titerations++;\n\t\t\t}\n\t\t\tif (style.verticalAlign === 'top') { offset.y = style.margin; } \n\t\t\telse if (style.verticalAlign === 'middle') { offset.y = (totalMaxHeight - size.height) / 2; }\n\t\t\telse if (style.verticalAlign === 'bottom') { offset.y = totalMaxHeight - style.margin - size.height; }\n\t\t\tthis._clear();\n\t\t\tthis._wrapText(size, offset, true);\n\t\t}\n\t\tcontext.restore();\n\t};\n\ttex._wrapText = function(size, offset, print) {\n\t\tvar lineHeight = fontSize * style.lineHeight;\n\t\tvar maxWidth = width - style.margin * 2;\n\n\t\tsize.width = 0;\n\t\tsize.height = offset.y;\n\t\tcontext.font = fontSize + 'px ' + style.font;\n\n\t\tvar lines = text.value.split('\\n');\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tsize.height += lineHeight;\n\t\t\tvar line = lines[i];\n\t\t\tvar words = line.split(' ');\n\t\t\tvar outLine = '';\n\t\t\tfor (var j = 0; j < words.length; j++) {\n\t\t\t\tvar testLine = outLine + words[j] + ' ';\n\t\t\t\tvar w = context.measureText(testLine).width;\n\t\t\t\t// If line+word exceeds width, print the line and start a new one\n\t\t\t\tif (w > maxWidth) {\n\t\t\t\t\tif (j === 0) {\n\t\t\t\t\t\tsize.width = Math.max(size.width, w);\n\t\t\t\t\t}\n\t\t\t\t\tif (print) { context.fillText(outLine, offset.x, size.height); }\n\t\t\t\t\toutLine = words[j] + ' ';\n\t\t\t\t\tsize.height += lineHeight;\n\t\t\t\t} else {\n\t\t\t\t\toutLine = testLine;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize.width = Math.max(size.width, context.measureText(outLine).width);\n\t\t\t// Print the last line\n\t\t\tif (print) { context.fillText(outLine, offset.x, size.height); }\n\t\t}\n\t};\n\treturn tex;\n}",
    "name": "Text texture",
    "license": "CC0",
    "created": "2014-11-25T11:34:03.773633+00:00",
    "deleted": false,
    "modified": "2014-11-25T11:34:03.773665+00:00",
    "originalAsset": {
      "version": "cf886b37d0554800895fa4fa8f16ce83",
      "id": "ec75a454fe384cee899665d6baf4d721"
    },
    "dataModelVersion": 2,
    "dependencies": {},
    "id": "72b440a4a1fd4493ba4f8d77b1399e4d.script"
  },
  "93cd06aae27c48d49d3edbb4a56017cb.texture": {
    "wrapS": "Repeat",
    "minFilter": "Trilinear",
    "name": "deathvalley_topomap_s.jpg",
    "license": "CC0",
    "flipY": true,
    "deleted": false,
    "magFilter": "Bilinear",
    "created": "2016-03-05T20:34:20.154Z",
    "dataModelVersion": 2,
    "modified": "2016-03-05T20:34:20.154Z",
    "matchFileName": "deathvalley_topomap_s.jpg",
    "repeat": [
      1,
      1
    ],
    "imageRef": "02bd18427e617411e11818ef2b383a4fd458b9a1.jpg",
    "offset": [
      0,
      0
    ],
    "id": "93cd06aae27c48d49d3edbb4a56017cb.texture",
    "generateMipmaps": true,
    "anisotropy": 1,
    "wrapT": "Repeat"
  },
  "cb3463698ada4635aaf75f1001f6233a.environment": {
    "sound": {
      "dopplerFactor": 0,
      "maxDistance": 100,
      "reverb": 0,
      "rolloffFactor": 0.4,
      "volume": 1
    },
    "globalAmbient": [
      0,
      0,
      0,
      0
    ],
    "license": "CC0",
    "created": "2015-07-27T15:45:29.143Z",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2015-07-27T15:45:29.143Z",
    "fog": {
      "color": [
        1,
        1,
        1
      ],
      "far": 996,
      "near": 0,
      "enabled": false
    },
    "backgroundColor": [
      0,
      0,
      0,
      1
    ],
    "weather": {
      "snow": {
        "velocity": 10,
        "rate": 10,
        "enabled": false,
        "height": 25
      }
    },
    "id": "cb3463698ada4635aaf75f1001f6233a.environment",
    "name": "Default Environment"
  },
  "28de9dae45fa4a43afd7989f5cae6098.posteffects": {
    "name": "Post effects",
    "license": "CC0",
    "created": "2015-07-27T15:45:29.145Z",
    "deleted": false,
    "dataModelVersion": 2,
    "posteffects": {},
    "modified": "2015-07-27T15:45:29.145Z",
    "id": "28de9dae45fa4a43afd7989f5cae6098.posteffects"
  },
  "8e4efdba57834dc2b90aef72b3a40088.script": {
    "body": "var setup = function(args, ctx, goo) {\n\tctx.lastEvent = null;\n\tctx.lastOrientation = null;\n\tctx.orientation = new goo.Matrix3x3();\n\tctx.rotation = new goo.Matrix3x3();\n\tctx.firstRotation = null;\n\t\n\tctx.lastMoveEvent = null;\n\tctx.firstMovement = null;\t\n\tctx.movement = new goo.Vector3();\n// \tctx.accXsmooth = 0;\n//     ctx.accYsmooth = 0;\n// \tctx.accZsmooth = 0;\n//     ctx.factor = 0.9998;\n\n\tctx.currentQuat = new goo.Quaternion();\n\tctx.targetQuat = new goo.Quaternion();\n\n\tctx.deviceAcceleration = function(evt) {\n\t\tif (evt.acceleration.x && evt.acceleration.y && evt.acceleration.z) {\n\t\t\tctx.lastMoveEvent = evt;\n\t\t}\n\t};\n\tctx.deviceOrientation = function(evt) {\n\t\tif (evt.alpha && evt.beta && evt.gamma) {\n\t\t\tctx.lastEvent = evt;\n\t\t}\n\t};\n\tctx.reset = function() {\n\t\tctx.firstRotation = null;\n\t\tctx.firstMovement = null;\n\t};\n\tgoo.SystemBus.addListener('gyro.reset', ctx.reset);\n\twindow.addEventListener('deviceorientation', ctx.deviceOrientation);\n\twindow.addEventListener('devicemotion', ctx.deviceAcceleration);\n};\n\nvar cleanup = function(args, ctx, goo) {\n\twindow.removeEventListener('deviceorientation', ctx.deviceOrientation);\n\twindow.removeEventListener('devicemotion', ctx.deviceAcceleration);\n\tgoo.SystemBus.removeListener('gyro.reset', ctx.reset);\n};\nvar update = function(args, ctx, goo) {\n\tif (ctx.lastEvent) {\n\t\t// Grab the orientation\n\t\tyxz(\n\t\t\tctx.rotation,\n\t\t\tctx.lastEvent.beta * goo.MathUtils.DEG_TO_RAD,\n\t\t\tctx.lastEvent.alpha * goo.MathUtils.DEG_TO_RAD,\n\t\t\t- ctx.lastEvent.gamma * goo.MathUtils.DEG_TO_RAD\n\t\t);\n\t\t// Adapt to screen.\n\t\t// We want the entity so that a camera would point towards -Z with Y up\n\t\tif (window.orientation !== undefined) {\n\t\t\tif (ctx.lastOrientation !== window.orientation) {\n\t\t\t\tctx.orientation.fromAngles(\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t- window.orientation * goo.MathUtils.DEG_TO_RAD,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tctx.lastOrientation = window.orientation;\n\t\t\t}\n\t\t} else if (window.innerWidth > window.innerHeight) {\n\t\t\tif (ctx.lastOrientation !== 'landscape') {\n\t\t\t\tctx.orientation.fromAngles(\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tctx.lastOrientation = 'landscape';\n\t\t\t}\n\t\t} else {\n\t\t\tif (ctx.lastOrientation !== 'portrait') {\n\t\t\t\tctx.orientation.fromAngles(\n\t\t\t\t\t- Math.PI / 2,\n\t\t\t\t\t0,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tctx.lastOrientation = 'portrait';\n\t\t\t}\n\t\t}\n\t\tctx.rotation.combine(ctx.orientation);\n\t\tif (!args.absolute) {\n\t\t\tif (!ctx.firstRotation) {\n\t\t\t\tctx.firstRotation = new goo.Matrix3x3();\n\t\t\t\tctx.firstRotation.copy(ctx.rotation).invert();\n\t\t\t}\n\t\t\tgoo.Matrix3x3.combine(ctx.firstRotation, ctx.rotation, ctx.rotation);\n\t\t}\n\t\tif (args.lerp === 1) {\n\t\t\tctx.entity.transformComponent.transform.rotation.copy(ctx.rotation);\n\t\t} else {\n\t\t\tctx.currentQuat.fromRotationMatrix(ctx.entity.transformComponent.transform.rotation);\n\t\t\tctx.targetQuat.fromRotationMatrix(ctx.rotation);\n\t\t\t\n\t\t\tctx.currentQuat.slerp(ctx.targetQuat, args.lerp);\n\t\t\tctx.currentQuat.toRotationMatrix(ctx.entity.transformComponent.transform.rotation);\n\t\t}\n\t\t\n// \t\tctx.entity.transformComponent.setUpdated();\n\t\tctx.lastEvent = null;\n\t}\n\t\n\tif (ctx.lastMoveEvent) {\n\t\t\tctx.currentPosition = ctx.entity.getTranslation();\n\t\t\tctx.movement = ctx.lastMoveEvent.acceleration;\n// \t\t    ctx.movement = (ctx.lastMoveEvent.acceleration.x, ctx.lastMoveEvent.acceleration.y, ctx.lastMoveEvent.acceleration.z);\n\t\t\tctx.currentPosition.lerp(ctx.movement, args.lerp);\n\t\t\tctx.entity.setTranslation(ctx.currentPosition.y, ctx.currentPosition.x, ctx.currentPosition.z);\n\t\t\tctx.lastMoveEvent = null;\n\t\t}\n};\n\nvar parameters = [{\n\tkey: 'absolute',\n\ttype: 'boolean',\n\tdefault: false\n}, {\n\tkey: 'lerp',\n\ttype: 'float',\n\tmin: 0,\n\tmax: 1,\n\tdefault: 0.9,\n\tcontrol: 'slider'\n}];\n\nfunction yxz(matrix, x, y, z) {\n\tvar d = matrix.data;\n\n\tvar cy = Math.cos(x);\n\tvar sy = Math.sin(x);\n\tvar ch = Math.cos(y);\n\tvar sh = Math.sin(y);\n\tvar cp = Math.cos(z);\n\tvar sp = Math.sin(z);\n\n\td[0] = ch * cp + sh * sp * sy;\n\td[3] = sh * cp * sy - ch * sp;\n\td[6] = cy * sh;\n\n\td[1] = cy * sp;\n\td[4] = cy * cp;\n\td[7] = - sy;\n\n\td[2] = ch * sp * sy - sh * cp;\n\td[5] = sh * sp + ch * cp * sy;\n\td[8] = cy * ch;\n}\n",
    "name": "device_sensors",
    "license": "CC0",
    "created": "2016-03-11T15:21:00.399Z",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2016-03-11T15:21:00.399Z",
    "dependencies": {},
    "id": "8e4efdba57834dc2b90aef72b3a40088.script"
  },
  "647ce9e6c5a74e879740fbd519c2be00.entity": {
    "name": "sky",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2016-02-24T09:27:23.859Z",
    "dataModelVersion": 2,
    "modified": "2016-02-24T09:27:23.859Z",
    "static": false,
    "components": {
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          0,
          0,
          0
        ]
      },
      "script": {
        "scripts": {
          "4dc237d4d0ec4d499492091e2228cec0.scriptinstance": {
            "id": "4dc237d4d0ec4d499492091e2228cec0.scriptinstance",
            "name": "Instance of video_loader",
            "scriptRef": "107c4dcd5e1c48e1989dd9086aafed2a.script",
            "sortValue": 0,
            "options": {
              "texture2": {
                "enabled": true
              },
              "texture1": {
                "enabled": true,
                "textureRef": "679f7c69547246e5a03cf501af127572.texture"
              },
              "enabled": false,
              "listenToStop": "stop",
              "listenToStart": "start"
            }
          }
        }
      }
    },
    "hidden": false,
    "id": "647ce9e6c5a74e879740fbd519c2be00.entity"
  },
  "843d5c34d3e6452fa3b44517b4b1488e.entity": {
    "name": "Directional 0",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2015-07-27T15:45:29.196Z",
    "dataModelVersion": 2,
    "modified": "2015-07-27T15:45:29.196Z",
    "static": false,
    "components": {
      "light": {
        "direction": [
          0,
          0,
          0
        ],
        "shadowCaster": false,
        "color": [
          1,
          1,
          1,
          1
        ],
        "intensity": 0.8,
        "range": 60,
        "specularIntensity": 1,
        "penumbra": 5,
        "angle": 30,
        "type": "DirectionalLight",
        "shadowSettings": {
          "fov": 55,
          "darkness": 1,
          "far": 60,
          "near": 1,
          "resolution": [
            256,
            256
          ],
          "shadowType": "Basic",
          "size": 100
        }
      },
      "transform": {
        "rotation": [
          -38,
          21,
          -18
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          16,
          20.5,
          23.3
        ]
      }
    },
    "hidden": false,
    "id": "843d5c34d3e6452fa3b44517b4b1488e.entity"
  },
  "814eb3d13be3459fba60f42e75bac6e7.entity": {
    "name": "heightmap",
    "license": "CC0",
    "created": "2016-03-09T13:02:33.545Z",
    "deleted": false,
    "tags": {},
    "dataModelVersion": 2,
    "modified": "2016-03-09T13:02:33.545Z",
    "static": false,
    "components": {
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          0,
          0,
          0
        ]
      },
      "script": {
        "scripts": {
          "b27aa7887a584b54b51f6a4a1d079bba.scriptinstance": {
            "scriptRef": "e46c79eb1221479fa6ea670616a3012a.script",
            "options": {
              "baseColor": [
                0,
                0,
                0
              ],
              "lineColor": [
                1,
                1,
                1
              ],
              "enabled": true,
              "texture": {
                "enabled": true,
                "textureRef": "93cd06aae27c48d49d3edbb4a56017cb.texture"
              },
              "transparency": false,
              "lineWidth": 1
            },
            "id": "6e2be119d65e4a62918cda83e34d628a.scriptInstance",
            "sortValue": 0,
            "name": "Custom script"
          }
        }
      }
    },
    "hidden": false,
    "id": "814eb3d13be3459fba60f42e75bac6e7.entity"
  },
  "9add1c4e82254fccb360ff1cd555c957.sound": {
    "name": "wind1",
    "license": "CC0",
    "created": "2016-03-11T22:11:24.024Z",
    "deleted": false,
    "audioRefs": {
      "mp3": "10072252dbacbea5dfd99e086586909e2d98d179.mp3"
    },
    "dataModelVersion": 2,
    "modified": "2016-03-11T22:11:24.024Z",
    "volume": 1,
    "spatialize": false,
    "id": "9add1c4e82254fccb360ff1cd555c957.sound",
    "loop": true,
    "autoPlay": true
  },
  "770efcf2e3ad4e5493ec103921c21a33.material": {
    "texturesMapping": {},
    "flat": false,
    "cullState": {
      "frontFace": "CCW",
      "enabled": true,
      "cullFace": "Back"
    },
    "uniforms": {
      "opacity": {
        "enabled": false,
        "value": 1
      },
      "refractivity": {
        "enabled": false,
        "value": 0
      },
      "materialAmbient": {
        "enabled": true,
        "value": [
          0,
          0,
          0,
          1
        ]
      },
      "materialSpecular": {
        "enabled": true,
        "value": [
          0.6,
          0.6,
          0.6,
          1
        ]
      },
      "fresnel": {
        "enabled": true,
        "value": 0
      },
      "reflectivity": {
        "enabled": true,
        "value": 0
      },
      "materialSpecularPower": {
        "enabled": true,
        "value": 64
      },
      "materialDiffuse": {
        "enabled": true,
        "value": [
          1,
          1,
          1,
          1
        ]
      },
      "vertexColorAmount": {
        "enabled": true,
        "value": 1
      },
      "materialEmissive": {
        "enabled": true,
        "value": [
          1,
          1,
          1,
          1
        ]
      },
      "discardThreshold": {
        "enabled": true,
        "value": 0.1
      },
      "normalMultiplier": {
        "enabled": true,
        "value": 1
      },
      "etaRatio": {
        "enabled": true,
        "value": -0.5
      },
      "reflectionType": 0,
      "wrapSettings": {
        "enabled": true,
        "value": [
          0,
          0
        ]
      }
    },
    "name": "Default Material",
    "license": "CC0",
    "created": "2016-03-07T16:49:56.269Z",
    "deleted": false,
    "wireframe": false,
    "dataModelVersion": 2,
    "blendState": {
      "blendEquation": "AddEquation",
      "blendSrc": "SrcAlphaFactor",
      "blendDst": "OneMinusSrcAlphaFactor",
      "blending": "TransparencyBlending"
    },
    "modified": "2016-03-07T16:49:56.269Z",
    "dualTransparency": true,
    "depthState": {
      "write": true,
      "enabled": true
    },
    "shaderRef": "GOO_ENGINE_SHADERS/uber",
    "id": "770efcf2e3ad4e5493ec103921c21a33.material",
    "renderQueue": -1
  },
  "679f7c69547246e5a03cf501af127572.texture": {
    "wrapS": "Repeat",
    "minFilter": "Trilinear",
    "imageRef": "run.mp4",
    "license": "CC0",
    "flipY": true,
    "deleted": false,
    "name": "run.mp4",
    "magFilter": "Bilinear",
    "created": "2016-02-24T12:58:55.972Z",
    "dataModelVersion": 2,
    "modified": "2016-02-24T12:58:55.972Z",
    "repeat": [
      1,
      1
    ],
    "lodBias": 0,
    "offset": [
      0,
      0
    ],
    "id": "679f7c69547246e5a03cf501af127572.texture",
    "lazy": true,
    "generateMipmaps": true,
    "anisotropy": 1,
    "wrapT": "Repeat"
  },
  "64f47c2064f746999a6db20581dbfb40.entity": {
    "name": "VR Camera",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2016-02-24T09:01:44.620Z",
    "dataModelVersion": 2,
    "originalAsset": {
      "version": "3557785339bf43edb490080807e0b2f8",
      "id": "35a0371261c349a2adbeb3ca0fedaf00"
    },
    "modified": "2016-02-24T09:01:44.620Z",
    "static": false,
    "components": {
      "sound": {
        "volume": 1,
        "sounds": {
          "9add1c4e82254fccb360ff1cd555c957.sound": {
            "soundRef": "9add1c4e82254fccb360ff1cd555c957.sound",
            "sortValue": 0
          }
        }
      },
      "camera": {
        "fov": 55,
        "lockedRatio": false,
        "far": 1000,
        "followEditorCam": false,
        "projectionMode": "Perspective",
        "near": 0.1,
        "aspect": 1,
        "size": 5
      },
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          0,
          0,
          1
        ],
        "children": {
          "763dc89e7b4649bea068cff5bd7797e4.entity": {
            "entityRef": "763dc89e7b4649bea068cff5bd7797e4.entity",
            "sortValue": 0
          }
        }
      },
      "script": {
        "scripts": {
          "7b1fc90a87914e22a7d57f7ce4247f6c.scriptinstance": {
            "id": "7b1fc90a87914e22a7d57f7ce4247f6c.scriptinstance",
            "name": "Custom script",
            "scriptRef": "f758d1b3cb4f4a43b36de389c39550d0.script",
            "sortValue": 2,
            "options": {
              "enabled": true
            }
          },
          "300b1bd8dc9547f3b681284a9329ccf9.scriptinstance": {
            "id": "300b1bd8dc9547f3b681284a9329ccf9.scriptinstance",
            "name": "Custom script",
            "scriptRef": "b88ee439142b4ba5b918fdc3fd3cc83d.script",
            "sortValue": 0,
            "options": {
              "boost3D": 2,
              "enabled": true
            }
          },
          "5609a7dbb0604b0589ff75b848384f2e.scriptinstance": {
            "id": "5609a7dbb0604b0589ff75b848384f2e.scriptinstance",
            "name": "Instance of 'MouseLookScript'",
            "scriptRef": "GOO_ENGINE_SCRIPTS/MouseLookScript",
            "sortValue": 3,
            "options": {
              "maxAscent": 89.95,
              "whenUsed": true,
              "maxAzimuth": 90,
              "button": "Left",
              "clampAzimuth": false,
              "enabled": true,
              "minAzimuth": -90,
              "minAscent": -89.95,
              "speed": 1
            }
          },
          "908a1db785594bcfaf67e824dcdaabee.scriptinstance": {
            "id": "908a1db785594bcfaf67e824dcdaabee.scriptinstance",
            "name": "Instance of Device Orientation script 2",
            "scriptRef": "8e4efdba57834dc2b90aef72b3a40088.script",
            "sortValue": 4,
            "options": {
              "absolute": false,
              "enabled": true,
              "lerp": 0.9
            }
          }
        }
      }
    },
    "hidden": false,
    "id": "64f47c2064f746999a6db20581dbfb40.entity"
  },
  "ae6a528167ca4709b0954b9ace7bcac8.entity": {
    "name": "text",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2016-03-09T13:26:50.691Z",
    "dataModelVersion": 2,
    "modified": "2016-03-09T13:26:50.691Z",
    "static": false,
    "components": {
      "meshData": {
        "shape": "Quad"
      },
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          10,
          10,
          10
        ],
        "translation": [
          -1.7056150436401367,
          5.023013114929199,
          -29.057449340820312
        ]
      },
      "meshRenderer": {
        "receiveShadows": true,
        "materials": {
          "770efcf2e3ad4e5493ec103921c21a33.material": {
            "materialRef": "770efcf2e3ad4e5493ec103921c21a33.material",
            "sortValue": 0
          }
        },
        "reflectable": true,
        "cullMode": "Dynamic",
        "castShadows": true
      },
      "script": {
        "scripts": {
          "5a517d930220410392b4583e88f840c2.scriptinstance": {
            "id": "5a517d930220410392b4583e88f840c2.scriptinstance",
            "name": "Instance of Text texture",
            "scriptRef": "72b440a4a1fd4493ba4f8d77b1399e4d.script",
            "sortValue": 0,
            "options": {
              "verticalAlign": "middle",
              "text": "LOADING TRACK",
              "enabled": true,
              "textAlign": "center",
              "wordWrap": true,
              "backgroundColor": [
                0,
                0,
                0
              ],
              "lineHeight": 1.3,
              "font": "Helvetica",
              "margin": 20,
              "transparent": true,
              "texSize": 512
            }
          }
        }
      }
    },
    "hidden": false,
    "id": "ae6a528167ca4709b0954b9ace7bcac8.entity"
  },
  "107c4dcd5e1c48e1989dd9086aafed2a.script": {
    "body": "'use strict';\n\n/* global goo */\n\nvar clamp = function(number, min, max) {\n  return Math.max(min, Math.min(number, max));\n};\n\nvar mouseMove = function(ctx, x, y) {\n\tctx.relative[0] = (x - ctx.rect.width/2.0);\n\tctx.relative[1] = (y - ctx.rect.height/2.0);\n\t// ctx.worldData.relative = ctx.relative;\n};\n\nvar setup = function (args, ctx) {\n\t\n\tctx.rect = ctx.domElement.getBoundingClientRect();\n\tgoo.SystemBus.addListener('goo.viewportResize', function() {\n\t\tctx.rect = ctx.domElement.getBoundingClientRect();\n\t});\n\tctx.relative = [0, 0];\n\tctx.relativeSmooth = [0, 0];\n\tctx.windowListeners = {\n\t\tmousemove: function(evt) {\n\t\tmouseMove(ctx, evt.clientX, evt.clientY);\n\t\t}\n\t};\n\tObject.keys(ctx.windowListeners).forEach(function(v) {\n\twindow.addEventListener(v, ctx.windowListeners[v]);\n\t});\n\t\n\t\n    goo.Ajax.crossOrigin = true;\n    \n    function createSkySphere(ctx, material) {\n        material.cullState.cullFace = 'Front'; // cull the outside, keep the inside\n        material.depthState.enabled = false; // don't change the z-buffer\n        material.renderQueue = -1000; // draw this first\n        var skysphere = ctx.world.createEntity(new goo.Sphere(32, 32, 20, goo.Sphere.TextureModes.Linear), material);\n        skysphere.isSkybox = true; // activate special handling in renderer and for shadows\n        return skysphere;\n    }\n    \n        ctx.material = new goo.Material(goo.ShaderLib.textured);\n        ctx.material.setTexture('DIFFUSE_MAP', args.texture1);\n        ctx.skySphere = createSkySphere(ctx, ctx.material);\n        ctx.skySphere.addToWorld();\n        ctx.skySphere.setRotation(-Math.PI*0.5, 0, 0);\n\t\tctx.video = ctx.material.getTexture('DIFFUSE_MAP').image;\n};\n\nvar cleanup = function (args, ctx) {\n    if(ctx.skySphere !== undefined){\n        ctx.skySphere.removeFromWorld();\n    }\n\tObject.keys(ctx.windowListeners).forEach(function(v) {\n\twindow.removeEventListener(v, ctx.windowListeners[v]);\n\t});\n\t\n};\n\nvar update = function (args, ctx) {\n\tctx.skySphere.setTranslation(0,Math.sin(goo.World.time*10),0);\n\tif(ctx.relative[1]!==0) {\n\t\tctx.video.playbackRate = clamp(Math.abs(Math.floor(ctx.relative[1]/10)/10),0,2);\n\t  }\n\t\tconsole.log(ctx.video.playbackRate);\n\n};\n\nvar parameters = [\n        {key:'listenToStart', name: 'listenToVideo1', type: 'string', default: 'start'},\n        {key:'listenToStop', name: 'listenToVideo2', type: 'string', default: 'stop'},\n        {key:'texture1', type:'texture', default:null},\n        {key:'texture2', type:'texture', default:null},\n    ];",
    "name": "video_loader",
    "license": "CC0",
    "created": "2016-02-22T12:41:57.196Z",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2016-02-22T12:41:57.196Z",
    "id": "107c4dcd5e1c48e1989dd9086aafed2a.script"
  },
  "49f8edb7fcc0471e964c33ad54196e20.scene": {
    "canvas": {
      "resolution": {
        "width": 1920,
        "height": 1080
      },
      "mode": "Stretch"
    },
    "initialCameraRef": "64f47c2064f746999a6db20581dbfb40.entity",
    "description": "VR running with 360 video",
    "license": "PRIVATE",
    "created": "2016-02-26T15:47:10.165690+00:00",
    "deleted": false,
    "id": "49f8edb7fcc0471e964c33ad54196e20.scene",
    "thumbnailRef": "9ce7d991e20821433d551c35728fae33d1eebc13.png",
    "environmentRef": "cb3463698ada4635aaf75f1001f6233a.environment",
    "dataModelVersion": 2,
    "originalAsset": {
      "version": "e39b6ff680c4402a9949b27c96f1729a",
      "id": "ac9f46781def41a38e654aa43175edba"
    },
    "modified": "2016-03-11T22:13:09.844316+00:00",
    "entities": {
      "4d2303a5ad484fea930530132d84ff03.entity": {
        "entityRef": "4d2303a5ad484fea930530132d84ff03.entity",
        "sortValue": 7
      },
      "64f47c2064f746999a6db20581dbfb40.entity": {
        "entityRef": "64f47c2064f746999a6db20581dbfb40.entity",
        "sortValue": 4
      },
      "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity": {
        "entityRef": "ebc5ac6898234f0d8eb1e629b2a7d6c4.entity",
        "sortValue": 0
      },
      "647ce9e6c5a74e879740fbd519c2be00.entity": {
        "entityRef": "647ce9e6c5a74e879740fbd519c2be00.entity",
        "sortValue": 6
      },
      "5de059f428574f899590bffcf9725071.entity": {
        "entityRef": "5de059f428574f899590bffcf9725071.entity",
        "sortValue": 1
      },
      "814eb3d13be3459fba60f42e75bac6e7.entity": {
        "entityRef": "814eb3d13be3459fba60f42e75bac6e7.entity",
        "sortValue": 8
      },
      "ae6a528167ca4709b0954b9ace7bcac8.entity": {
        "entityRef": "ae6a528167ca4709b0954b9ace7bcac8.entity",
        "sortValue": 9
      },
      "1357bc80a1434a92bd41040591f474f2.entity": {
        "entityRef": "1357bc80a1434a92bd41040591f474f2.entity",
        "sortValue": 3
      }
    },
    "posteffectsRef": "28de9dae45fa4a43afd7989f5cae6098.posteffects",
    "published": "2016-03-11T22:13:08.292062+00:00",
    "packs": {
      "438f67eaff1f4e8b91f97c3d3eeaf431.pack": {
        "packRef": "438f67eaff1f4e8b91f97c3d3eeaf431.pack",
        "sortValue": 0
      },
      "12c02855070841e592dec1864cc355f3.pack": {
        "packRef": "12c02855070841e592dec1864cc355f3.pack",
        "sortValue": 5
      },
      "56ac7215e0f64edba617e5b0c095b796.pack": {
        "packRef": "56ac7215e0f64edba617e5b0c095b796.pack",
        "sortValue": 3
      },
      "7cc0eb88b0de4331b605d6677bde8ea9.pack": {
        "packRef": "7cc0eb88b0de4331b605d6677bde8ea9.pack",
        "sortValue": 4
      },
      "2739083de95c4dc5addb4e43fc558dd0.pack": {
        "packRef": "2739083de95c4dc5addb4e43fc558dd0.pack",
        "sortValue": 1
      },
      "de72882b03ef4e89baab5c3c853e228c.pack": {
        "packRef": "de72882b03ef4e89baab5c3c853e228c.pack",
        "sortValue": 7
      },
      "15fc0617a6d543eba6f64e65779707c1.pack": {
        "packRef": "15fc0617a6d543eba6f64e65779707c1.pack",
        "sortValue": 8
      }
    },
    "defaultPackRef": "438f67eaff1f4e8b91f97c3d3eeaf431.pack",
    "publishedUrl": "https://c1.goote.ch/49f8edb7fcc0471e964c33ad54196e20.scene",
    "name": "VRun"
  },
  "c74e3e7e0a354362bb528f8a38d3dbff.entity": {
    "name": "Directional 1",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2015-07-27T15:45:29.198Z",
    "dataModelVersion": 2,
    "modified": "2015-07-27T15:45:29.198Z",
    "static": false,
    "components": {
      "light": {
        "direction": [
          0,
          0,
          0
        ],
        "shadowCaster": false,
        "color": [
          1,
          1,
          1,
          1
        ],
        "intensity": 0.4,
        "range": 60,
        "specularIntensity": 1,
        "penumbra": 5,
        "angle": 30,
        "type": "DirectionalLight",
        "shadowSettings": {
          "fov": 55,
          "darkness": 1,
          "far": 60,
          "near": 1,
          "resolution": [
            256,
            256
          ],
          "shadowType": "Basic",
          "size": 100
        }
      },
      "transform": {
        "rotation": [
          -31,
          129,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          15,
          11.6,
          -12.2
        ]
      }
    },
    "hidden": false,
    "id": "c74e3e7e0a354362bb528f8a38d3dbff.entity"
  },
  "b88ee439142b4ba5b918fdc3fd3cc83d.script": {
    "body": "\nvar setup = function(args, ctx, goo) {\n\tctx.pass = new RiftRenderPass(args, ctx, goo);\n\tctx.enabled = false;\n\t\n\tvar fov = ctx.entity.cameraComponent ? ctx.entity.cameraComponent.camera.fov : 80;\n\t\n\tctx.pass.updateConfig({\n\t\tdistortionK: [1.0, 0.0,0.0,0],\n\t\tchromAbParameter: [1,0,1,0],\n\t\tlensSeparationDistance: 0.096,\n\t\thResolution: ctx.viewportWidth,\n\t\tvResolution: ctx.viewportHeight,\n\t\thScreenSize: 0.128,\n\t\tvScreenSize: 0.192,\n\t\tinterpupillaryDistance: 0.096,\n\t\tFOV: fov\n\t});\n};\n\nvar cleanup = function(args, ctx, goo) {\n\tif (ctx.enabled) {\n\t\tPassSwitcher.switchBack(ctx, goo);\n\t}\n};\n\nvar update = function (args, ctx, goo) {\n\tif (ctx.activeCameraEntity === ctx.entity && !ctx.enabled) {\n\t\tPassSwitcher.switchPass(ctx.pass, ctx, goo);\n\t\tctx.enabled = true;\n\t} else if (ctx.activeCameraEntity !== ctx.entity && ctx.enabled) {\n\t\tPassSwitcher.switchBack(ctx, goo);\n\t\tctx.enabled = false;\n\t}\n}\n\nvar parameters = [{\n\tkey: 'boost3D',\n\tname: 'Boost 3D Effect',\n\ttype: 'float',\n\tcontrol: 'slider',\n\t'default': 1,\n\tmin: 1,\n\tmax: 20\n}];\n\n'use strict';\n(function() {\n\tfunction RiftRenderPass(args, ctx, goo) {\n\t\tthis.goo = goo;\n\t\tthis.ctx = ctx;\n\t\t\n\t\tthis.camera = new goo.Camera();\n\t\tthis.fullscreenCamera = goo.FullscreenUtil.camera;\n\t\tthis.renderToScreen = false;\n\t\tthis.clear = true;\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = true;\n\t\tthis.eyeOffset = 0.4;\n\t\tthis.fov = 100;\n\t\tthis.width = null;\n\t\tthis.height = null;\n\t\tthis._dc = 1.8; // Distortion compensation scale\n\n\t\t\n\t\t// Create composit\n\t\tthis.material = new goo.Material('Composit material', riftShader);\n\t\t\n\t\t// Create eye targets\n\t\tthis.updateSize({ width: ctx.viewportWidth, height: ctx.viewportHeight});\n\t\tthis.offsetVector = new goo.Vector3();\n\n\t\t\n\t\tthis.renderable = {\n\t\t\tmeshData: goo.FullscreenUtil.quad,\n\t\t\tmaterials: [this.material]\n\t\t};\n\n\t\t// get the renderlist\n\t\tthis.renderList = ctx.world.getSystem('RenderSystem').renderList;\n\t\tthis.setup(args, ctx, goo);\n\t}\n\t\n\tRiftRenderPass.prototype.setup = function(args) {\n\t\tthis.boost = args.boost3D || 1;\n\t};\n\tRiftRenderPass.prototype.destroy = function (renderer) {\n\t\tthis.leftTarget.destroy(renderer.context);\n\t\tthis.rightTarget.destroy(renderer.context);\n\t\tthis.leftTarget = null;\n\t\tthis.rightTarget = null;\n\t}\n\n\tRiftRenderPass.prototype.updateConfig = function (config) {\n\t\tvar uniforms = this.material.uniforms;\n\t\tuniforms.distortion = config.distortionK;\n\t\tuniforms.aberration = config.chromAbParameter;\n\t\tuniforms.lensCenterOffset = [\n\t\t\tconfig.lensSeparationDistance / config.hScreenSize - 0.5,\n\t\t\t0\n\t\t];\n\t\tthis.fov = config.FOV;\n\t\tthis.eyeOffset = config.interpupillaryDistance * this.boost;\n\n\n\t\tvar r = -1.0 - (4 * (config.hScreenSize/4 - config.lensSeparationDistance/2) / config.hScreenSize);\n\t\tvar distScale = (config.distortionK[0] +\n\t\t\tconfig.distortionK[1] * Math.pow(r,2) +\n\t\t\tconfig.distortionK[2] * Math.pow(r,4) +\n\t\t\tconfig.distortionK[3] * Math.pow(r,6));\n\t\tuniforms.scale = [\n\t\t\t1 / distScale,\n\t\t\t1 / distScale\n\t\t];\n\t\tthis.updateSize({ width: config.hResolution, height: config.vResolution })\n\t}\n\t\n\n\n\tRiftRenderPass.prototype.updateSize = function(size, renderer) {\n\t\tthis.material.uniforms.scaleIn = [\n\t\t\tsize.width * 0.5 / size.height,\n\t\t\t1\n\t\t];\n\t\tif (this.width === size.width && this.height === size.height) { return; }\n\t\tthis.width = size.width;\n\t\tthis.height = size.height;\n\t\tif (this.leftTarget) {\n\t\t\tthis.leftTarget.destroy(renderer.context)\n\t\t\tthis.rightTarget.destroy(renderer.context)\n\t\t}\n\t\t// size = { width: 2048, height: 2048 };\n\t\tthis.leftTarget = new this.goo.RenderTarget(size.width * 0.5 * this._dc, size.height * this._dc);\n\t\tthis.rightTarget = new this.goo.RenderTarget(size.width * 0.5 * this._dc, size.height * this._dc);\n\t};\n\n\tRiftRenderPass.prototype.render = function (\n\t\trenderer,\n\t\twriteBuffer,\n\t\treadBuffer,\n\t\tdelta,\n\t\tmaskActive,\n\t\tcamera,\n\t\tlights,\n\t\tclearColor\n\t) {\n\t\tcamera = camera || this.goo.Renderer.mainCamera;\n\t\tif (!camera) { return; }\n\t\tthis.camera.copy(camera);\n\t\tthis.camera.setFrustumPerspective(this.fov, 1);\n\t\tlights = lights || [];\n\t\tvar renderList = this.renderList;\n\t\t\n\t\t// Left eye\n\t\tthis.offsetVector.setVector(this.camera._left).scale(this.eyeOffset);\n\t\tthis.camera.translation.addVector(this.offsetVector);\n\t\tthis.camera.update();\n\t\trenderer.render(renderList, this.camera, lights, this.leftTarget, this.clear);\n\t\t\n\t\t// Right eye\n\t\tthis.offsetVector.scale(2);\n\t\tthis.camera.translation.subVector(this.offsetVector);\n\t\tthis.camera.update();\n\t\trenderer.render(renderList, this.camera, lights, this.rightTarget, this.clear);\n\t\t\n\t\t// Composit\n\t\tthis.material.setTexture('LEFT_TEX', this.leftTarget);\n\t\tthis.material.setTexture('RIGHT_TEX', this.rightTarget);\n\t\tif (this.renderToScreen) {\n\t\t\trenderer.render(this.renderable, this.fullscreenCamera, [], null, this.clear);\n\t\t} else {\n\t\t\trenderer.render(this.renderable, this.fullscreenCamera, [], writeBuffer, this.clear);\n\t\t}\n\t};\n\t\n\tRiftRenderPass.parameters = [{\n\t\tkey: 'eyeDistance',\n\t\ttype: 'float',\n\t\tmin: 0.0,\n\t\tmax: 0.4,\n\t\t'default': 0.1,\n\t\tcontrol: 'slider'\n\t}]\t\n\tvar riftShader = {\n\t\tattributes : {\n\t\t\tvertexPosition : 'POSITION',\n\t\t\tvertexUV0 : 'TEXCOORD0'\n\t\t},\n\t\tuniforms : {\n\t\t\tviewMatrix: 'VIEW_MATRIX',\n\t\t\tprojectionMatrix: 'PROJECTION_MATRIX',\n\t\t\tworldMatrix: 'WORLD_MATRIX',\n\t\t\tleftTex: 'LEFT_TEX',\n\t\t\trightTex: 'RIGHT_TEX',\n\t\t\tlensCenterOffset: [0, 0],\n\t\t\tdistortion: [1, 0.22, 0.24, 0],\n\t\t\taberration: [0.996, -0.004, 1.014, 0],\n\t\t\tscaleIn: [1,1],\n\t\t\tscale: [0.8,0.8]\n\t\t},\n\t\tvshader: [\n\t\t\t'attribute vec3 vertexPosition;',\n\t\t\t'attribute vec2 vertexUV0;',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 worldMatrix;',\n\n\t\t\t'varying vec2 vUv;',\n\t\t\t'void main() {',\n\t\t\t\t'vUv = vertexUV0;',\n\t\t\t\t'gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4( vertexPosition, 1.0 );',\n\t\t\t'}'\n\t\t].join('\\n'),\n\t\tfshader: [\n\t\t\t'uniform sampler2D leftTex;',\n\t\t\t'uniform sampler2D rightTex;',\n\n\t\t\t'uniform vec2 scaleIn;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 lensCenterOffset;',\n\t\t\t'uniform vec4 distortion;',\n\t\t\t'uniform vec4 aberration;',\n\t\t\t\n\t\t\t'varying vec2 vUv;',\n\n\t\t\t'vec2 distort(vec2 texCoords, vec2 ab) {',\n\t\t\t\t// 'vec2 lensOffset = vUv.x > 0.5 ? lensCenterOffset: -lensCenterOffset;',\n\t\t\t\t'vec2 lensCoords = ((texCoords * 2.0 - 1.0) - lensCenterOffset) * scaleIn;',\n\n\t\t\t\t'float rSq = dot(lensCoords, lensCoords);',\n\t\t\t\t'vec4 r = vec4(1.0, rSq, rSq*rSq, rSq*rSq*rSq);',\n\n\t\t\t\t'vec2 newCoords = lensCoords * dot(ab, r.xy) * dot(distortion, r);',\n\t\t\t\t'return ((newCoords * scale + lensCenterOffset) + 1.0) / 2.0;',\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\t\t\t\t'vec2 coord = vUv;',\n\t\t\t\t'if (vUv.x > 0.5) {', // Right eye\n\t\t\t\t\t'coord.x = 1.0 - coord.x;',\n\t\t\t\t'}',\n\t\t\t\t'coord.x *= 2.0;',\n\n\t\t\t\t'vec2 blue = distort(coord, aberration.zw);',\n\t\t\t\t'if (!all(equal(clamp(blue, vec2(0.0), vec2(1.0)), blue))) {',\n\t\t\t\t\t'discard;',\n\t\t\t\t'}',\n\n\t\t\t\t'vec2 red = distort(coord, aberration.xy);',\n\t\t\t\t'vec2 green = distort(coord, vec2(1.0, 0.0));',\n\t\t\t\t'gl_FragColor.a = 1.0;',\n\t\t\t\t'if (vUv.x > 0.5) {',\n\t\t\t\t\t'red.x = 1.0 - red.x;',\n\t\t\t\t\t'green.x = 1.0 - green.x;',\n\t\t\t\t\t'blue.x = 1.0 - blue.x;',\n\n\t\t\t\t\t'gl_FragColor.r = texture2D(rightTex, red).r;',\n\t\t\t\t\t'gl_FragColor.g = texture2D(rightTex, green).g;',\n\t\t\t\t\t'gl_FragColor.b = texture2D(rightTex, blue).b;',\n\t\t\t\t'} else {',\n\t\t\t\t\t'gl_FragColor.r = texture2D(leftTex, red).r;',\n\t\t\t\t\t'gl_FragColor.g = texture2D(leftTex, green).g;',\n\t\t\t\t\t'gl_FragColor.b = texture2D(leftTex, blue).b;',\n\t\t\t\t'}',\n\t\t\t'}'\n\t\t].join('\\n')\n\t};\n\n\twindow.RiftRenderPass = RiftRenderPass;\n}());\n\n'use strict';\n(function(global) {\n\tvar originalPass = null;\n\tvar originalComposer = null;\n\tvar addedPass = null;\n\t\n\tvar PassSwitcher = {\n\t\tswitchPass: function(pass, ctx, goo) {\n\t\t\taddedPass = pass;\n\t\t\tvar renderSystem = ctx.world.getSystem('RenderSystem');\n\t\t\t// Get or create composer\n\t\t\tvar composer\n\t\t\tif (renderSystem.composers.length) {\n\t\t\t\tcomposer = renderSystem.composers[0];\n\t\t\t\toriginalPass = composer.passes.shift();\n\t\t\t\tpass.renderToScreen = false;\n\t\t\t} else {\n\t\t\t\toriginalComposer = composer = new goo.Composer();\n\t\t\t\trenderSystem.composers.push(composer);\n\t\t\t\tpass.renderToScreen = true;\n\t\t\t}\n\t\t\t// Add the post effect\n\t\t\tcomposer.passes.unshift(pass);\n\t\t\tif (composer.size) {\n\t\t\t\tif (pass.updateSize instanceof Function) {\n\t\t\t\t\tpass.updateSize(composer.size, ctx.world.gooRunner.renderer);\n\t\t\t\t}\n\t\t\t\tpass.viewportSize = composer.size;\n\t\t\t}\n\t\t},\n\t\tswitchBack: function(ctx, goo) {\n\t\t\tvar renderSystem = ctx.world.getSystem('RenderSystem');\n\t\t\tif (originalComposer) {\n\t\t\t\toriginalComposer.destroy(ctx.world.gooRunner.renderer)\n\t\t\t\t// If we created a post effect chain, remove it\n\t\t\t\tgoo.ArrayUtil.remove(renderSystem.composers, originalComposer);\n\t\t\t} else {\n\t\t\t\t// Otherwise, remove the post effect and put back the outpass\n\t\t\t\tvar composer = renderSystem.composers[0];\n\t\t\t\tgoo.ArrayUtil.remove(composer.passes, addedPass);\n\t\t\t\tcomposer.passes.unshift(originalPass);\n\t\t\t}\n\t\t}\n\t};\n\tglobal.PassSwitcher = PassSwitcher;\n}(window));",
    "name": "VR Render Script",
    "license": "CC0",
    "created": "2015-06-25T11:28:03.992781+00:00",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2015-06-25T11:28:05.534532+00:00",
    "dependencies": {},
    "id": "b88ee439142b4ba5b918fdc3fd3cc83d.script"
  },
  "e46c79eb1221479fa6ea670616a3012a.script": {
    "body": "var addBarycentric = function (entity) {\n\tentity.meshDataComponent.meshData = entity.meshDataComponent.meshData.buildFlatMeshData();\n\tvar meshData = entity.meshDataComponent.meshData;\n\n\tmeshData.attributeMap.BARYCENTRIC = goo.MeshData.createAttribute(3, 'Float');\n\tmeshData.rebuildData(meshData.vertexCount, 0, true);\n\n\tvar barycentricBuffer = meshData.getAttributeBuffer('BARYCENTRIC');\n\tvar vertexCount = meshData.vertexCount;\n\tfor (var a = 0; a < vertexCount; a += 3) {\n\t\tbarycentricBuffer[a * 3 + 0] = 1;\n\t\tbarycentricBuffer[a * 3 + 1] = 0;\n\t\tbarycentricBuffer[a * 3 + 2] = 0;\n\t\tbarycentricBuffer[a * 3 + 3] = 0;\n\t\tbarycentricBuffer[a * 3 + 4] = 1;\n\t\tbarycentricBuffer[a * 3 + 5] = 0;\n\t\tbarycentricBuffer[a * 3 + 6] = 0;\n\t\tbarycentricBuffer[a * 3 + 7] = 0;\n\t\tbarycentricBuffer[a * 3 + 8] = 1;\n\t}\n};\n\nvar parameters = [\n\t{key:'texture', type:'texture', default:null},\n \t{ key: 'lineWidth', type: 'float', default: 1 },\n    { key: 'baseColor', type: 'vec3', control: 'color', default: [0, 0, 0] },\n    { key: 'lineColor', type: 'vec3', control: 'color', default: [1, 1, 1] },\n    { key: 'transparency', type: 'boolean', default: false }\t\n];\n\t\nvar setup = function(args, ctx, goo){\n\t\n\tvar material = new goo.Material('WireShader', wireShaderDef);\n\tmaterial.uniforms.lineWidth = args.lineWidth;\n\tmaterial.uniforms.baseColor = args.baseColor;\n\tmaterial.uniforms.lineColor = args.lineColor;\n\tmaterial.uniforms.transparency = args.transparency;\n//\tmaterial.blendState.blending = 'AdditiveBlending';\n\tif (args.transparency) {\n\t\tmaterial.blendState.blending = 'TransparencyBlending';\n\t\tmaterial.renderQueue = goo.RenderQueue.TRANSPARENT;\n\t}\n\n\t\tvar image = args.texture.image;\n\t\tvar imgCanvas = document.createElement('canvas');\n\t\timgCanvas.width = image.width;\n\t\timgCanvas.height = image.height;\n\t\timgCanvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);\n\t\t\n\t\tfunction getHeightMap(canvas, scale) {\n\t\t\tvar matrix = [];\n\t\t\tfor (var y = 0, ylen = canvas.height; y < ylen; y++) {\n\t\t\t\tmatrix.push([]);\n\t\t\t\tfor (var x = 0, xlen = canvas.width; x < xlen; x++) {\n\t\t\t\t\tvar rgb = canvas.getContext('2d').getImageData(x, y, 1, 1).data;\n\t\t\t\t\tvar value = rgb[0]+rgb[1]+rgb[2] / 3;\n\t\t\t\t\tmatrix[y].push(value * scale);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matrix;\n\t\t}\n\t\t\n\t\n\t\t\n\t\tvar heightMap = getHeightMap(imgCanvas, 0.06);\n\t\tvar meshData = goo.Surface.createFromHeightMap(heightMap, 5, 5, 5);\n// \t\tvar material = new goo.Material(goo.ShaderLib.simpleLit);\n\t\n\t\tmaterial.cullState.enabled = false;\n\t\t\n\t\tctx.worldData.heightMap = ctx.world.createEntity(meshData, material).addToWorld();\n\t\tctx.worldData.heightMap.transformComponent.setTranslation(-750,-20,-730);\n\t\tctx.worldData.heightMap.transformComponent.setUpdated();\n\t\taddBarycentric(ctx.worldData.heightMap);\n// \t\tconsole.log(ctx.heightMap);\n\n};\n\nvar cleanup = function(args, ctx, goo){\n\tif(ctx.worldData.heightMap !== undefined){\n\t\tctx.worldData.heightMap.removeFromWorld();\n\t}\n};\n\n\nvar wireShaderDef = {\n\tprocessors: [\n\t\tgoo.ShaderBuilder.animation.processor\n\t],\n\tdefines: {\n\t\tSHADOW_TYPE: 0,\n\t\tFOG:true,\n\t\tWEIGHTS: true,\n\t\tJOINTIDS: true\n\t},\n\tattributes: {\n\t\tvertexPosition: goo.MeshData.POSITION,\n\t\tvertexNormal: goo.MeshData.NORMAL,\n\t\tvertexUV0: goo.MeshData.TEXCOORD0,\n\t\tvertexColors: goo.MeshData.COLOR,\n\t\tvertexJointIDs: goo.MeshData.JOINTIDS,\n\t\tvertexWeights: goo.MeshData.WEIGHTS,\n\t\tbarycentric: 'BARYCENTRIC'\n\t},\n\tuniforms: {\n\t\tviewProjectionMatrix: goo.Shader.VIEW_PROJECTION_MATRIX,\n\t\tworldMatrix: goo.Shader.WORLD_MATRIX,\n\t\tdiffuseMap: goo.Shader.DIFFUSE_MAP,\n\t\tcameraPosition: goo.Shader.CAMERA,\n\t\tnormalMatrix: goo.Shader.NORMAL_MATRIX,\n\t\tlineWidth: 1,\n\t\tbaseColor: [0.0, 0.0, 0.0],\n\t\tlineColor: [1.0, 1.0, 1.0],\n\t\ttransparency: false,\n\t\tfogSettings: function() {return goo.ShaderBuilder.FOG_SETTINGS;},\n\t\tfogColor: goo.ShaderBuilder.FOG_COLOR,\n\t\tu_time : function() {return goo.World.time;}\n\t},\n\tvshader: [\n\t\t'attribute vec3 vertexPosition;',\n\t\t'attribute vec3 vertexColors;',\n\t\t'attribute vec2 vertexUV0;',\n\t\t\"attribute vec3 vertexNormal;\",\n\t\t'attribute vec3 barycentric;',\n\n\t\t'uniform mat4 viewProjectionMatrix;',\n\t\t'uniform mat4 worldMatrix;',\n\t\t'uniform mat3 normalMatrix;',\n\t\t\"uniform vec3 cameraPosition;\",\n\t\t\"uniform float u_time;\",\n\t\t\t\t\n\t\t\"varying vec3 viewPosition;\",\n\t\t'varying vec2 texCoord0;',\n\t\t'varying vec3 color;',\n\t\t'varying vec3 vBC;',\n\t\t\"varying vec3 normal;\",\n\t\t\"varying vec4 worldPos;\",\n\t\t\n\t\t'#ifdef FOG',\n\t\t\t'uniform vec2 fogSettings;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t'#endif',\n\n\t\tgoo.ShaderBuilder.animation.prevertex,\n\n\t\t'void main(void) {',\n\t\t\t'color = vertexColors;',\n\t\t\t'mat4 wMatrix = worldMatrix;',\n\t\t\tgoo.ShaderBuilder.animation.vertex,\n\t\t\t'texCoord0 = vertexUV0;',\n\t\t\t'vBC = barycentric;',\n\t\t\t\"worldPos = worldMatrix * vec4(vertexPosition, 1.0);\",\n\t\t\t'gl_Position = viewProjectionMatrix * worldPos;',\n\t\t\t\"viewPosition = cameraPosition - worldPos.xyz;\",\n\t\t\t\"normal = (worldMatrix * vec4(vertexNormal, 0.0)).xyz;\",\n\t\t'}'\n\t].join('\\n'),\n\tfshader: [\n\t\t'uniform sampler2D diffuseMap;',\n\t\t'uniform float lineWidth;',\n\t\t'uniform vec3 baseColor;',\n\t\t'uniform vec3 lineColor;',\n\t\t'uniform bool transparency;',\n\t\t'uniform mat3 normalMatrix;',\n\t\t\"uniform float u_time;\",\n\n\t\t'varying vec2 texCoord0;',\n\t\t'varying vec3 vBC;',\n\t\t'varying vec3 color;',\n\t\t\"varying vec3 viewPosition;\",\n\t\t\"varying vec3 normal;\",\n\t\t\"varying vec4 worldPos;\",\n\t\t\n\t\t'#ifdef FOG',\n\t\t\t'uniform vec2 fogSettings;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t '#endif',\n\n\t\t'#extension GL_OES_standard_derivatives : enable',\n\n\t\t'float edgeFactor() {',\n\t\t\t'vec3 d = fwidth(vBC);',\n\t\t\t'vec3 a3 = smoothstep(vec3(0.0), d * lineWidth, vBC);',\n\t\t\t'return 1.0 - min(min(a3.x, a3.y), a3.z);',\n\t\t'}',\n\n\t\t'void main(void) {',\n\t\t\t'float edge = edgeFactor();',\n// \t\t\t'vec3 lines = lineColor*color;',\n// \t\t\t'vec3 fill = baseColor*color;',\n\t\t\t'vec3 dark = vec3(0.0,0.0,0.0);',\n\t/*\t\t\n\t\t\t'float bValue = 0.0;',\n\t\t\t'float Radius = 10.0;',\n\n\t\t\t'float distanceCalculation = distance(viewPosition*(0.0-(Radius/10000.0)), worldPos.xyz*(0.0-(Radius/10000.0)));',\n\t\t\t'vec3 eyeNormal = (normalMatrix*normal)* 0.5 + 0.5;',\n\t\t\t'float cFresnel = clamp(dot(viewPosition, eyeNormal),0.0,1.0);',\n\t\t\t'vec3 invertFresnel = vec3(1, 1, 1) - vec3(cFresnel, cFresnel, cFresnel);',\n\t\t\t'float scanSync = clamp((mix(cFresnel, bValue, distanceCalculation)),0.0,1.0);',\n\t\t\t'float manualScan = clamp((((distance(viewPosition, worldPos.xyz))-100000.0)/10000.0),0.0,1.0);',\n\t\t\n\t*/\t\n\t\t/*\n\t\t\t'if (transparency) {',\n\t\t\t\t'gl_FragColor = vec4(lines, edge);',\n\t\t\t'} else {',\n\t\t\t\t'gl_FragColor.rgb = mix(fill, lines, edge);',\n\t\t\t\t'gl_FragColor.a = 1.0;',\n\t\t\t'}',\n\t\t*/\n\t\t'vec3 mainColor = mix(baseColor, lineColor*1.5, edge);',\n\t\t'vec3 linesOnly = mix(dark, lineColor*1.5, edge);',\n\t\t\n//    \t\t'float dist1 = pow(smoothstep(fogSettings.x, fogSettings.y, tan(length(viewPosition))), 1.0);',\n//\t\t\t'float dist2 = pow(smoothstep(fogSettings.x, fogSettings.y, tan(length(viewPosition))), 0.2);',\n//\t\t\t'float dist3 = pow(smoothstep(0.0, 100.0, tan(length(viewPosition*clamp(cos(u_time*0.1)*0.2, 0.0,1.0)))*0.7), 0.2);',\n\t\t\t'float dist3 = pow(smoothstep(0.0, 50.0, tan(length(viewPosition)*0.004-fract(u_time*0.01)*100.0)), 0.6);',\n\t\t\t'vec3 fog1 = mix(dark, mainColor, dist3);',\n\t\t\t'vec3 fog2 = mix(dark, fogColor,  dist3);',\n      \t\t'gl_FragColor.rgb = fog1+fog2/3.0;',\n// \t\t\t'gl_FragColor.rgb = mainColor;',\n\t\t\t\n// \t\t\t'if (transparency) {',\n//                 'gl_FragColor = vec4(lineColor, edge);',\n//             '} else {',\n// // \t\t\t\t'vec3 line = mix(lineColor, fogColor, worldPos.y);',\n//                 'gl_FragColor.rgb = mix(baseColor, lineColor, edge);',\n// \t\t\t'}',\n\t\t\t'gl_FragColor.a = 1.0;',\n//\t\t\t'gl_FragColor.rgb = fog1;',\n\n\t\t'}'\n\t].join('\\n')\n};\n",
    "name": "height_map",
    "license": "CC0",
    "created": "2015-02-03T14:17:11.627030+00:00",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2015-02-03T14:17:11.627030+00:00",
    "dependencies": {
      "https://code.gooengine.com/latest/lib/geometrypack.js": {
        "url": "https://code.gooengine.com/latest/lib/geometrypack.js",
        "sortValue": 0
      }
    },
    "id": "e46c79eb1221479fa6ea670616a3012a.script"
  },
  "f262bb7418044b34ae6100230b7988c4.script": {
    "body": "/**\n * Stream video in Goo Create!\n * 1. Upload a video to Create by dropping the file into the asset bin.\n * 2. Put it in the videoTexture slot in this script.\n * 3. Publish.\n * 4. Copy the URL of the video in the published scene.\n * 5. Paste the URL in the videoUrl parameter input.\n * 6. Set the texture as lazy load.\n * 7. Done!\n */\n\n'use strict';\n\n/* global goo */\n\nvar clamp = function(number, min, max) {\n  return Math.max(min, Math.min(number, max));\n};\n\nvar mouseMove = function(ctx, x, y) {\n\tctx.relative[0] = (x - ctx.rect.width/2.0);\n\tctx.relative[1] = (y - ctx.rect.height/2.0);\n\t// ctx.worldData.relative = ctx.relative;\n};\n\nvar setup = function (args, ctx) {\n\tfunction createSkySphere(ctx, material) {\n        material.cullState.cullFace = 'Front'; // cull the outside, keep the inside\n        material.depthState.enabled = false; // don't change the z-buffer\n        material.renderQueue = -1000; // draw this first\n        var skysphere = ctx.world.createEntity(new goo.Sphere(32, 32, 20, goo.Sphere.TextureModes.Linear), material);\n        skysphere.isSkybox = true; // activate special handling in renderer and for shadows\n        return skysphere;\n    }\n\t\n\tvar video = document.createElement('video');\n\tvideo.src = args.videoUrl;\n\tvideo.oncanplay = function(){\n\t\tctx.canPlay = true;\n\t\tctx.video = video;\n\t};\n\t\n// \t\tctx.rect = ctx.domElement.getBoundingClientRect();\n// \tgoo.SystemBus.addListener('goo.viewportResize', function() {\n// \t\tctx.rect = ctx.domElement.getBoundingClientRect();\n// \t});\n// \tctx.relative = [0, 0];\n// \tctx.relativeSmooth = [0, 0];\n// \tctx.windowListeners = {\n// \t\tmousemove: function(evt) {\n// \t\tmouseMove(ctx, evt.clientX, evt.clientY);\n// \t\t}\n// \t};\n// \tObject.keys(ctx.windowListeners).forEach(function(v) {\n// \twindow.addEventListener(v, ctx.windowListeners[v]);\n// \t});\n\t\t\n\tctx.listeners = {\n\t\tmousedown: function(){\n\t\t\tif(ctx.canPlay && !ctx.started){\n\t\t\t\tctx.world.by.name('text').first().hide();\n\t\t\t\tctx.worldData.heightMap.hide();\n\t\t\t\tvideo.play();\n\t\t\t\tvideo.width = video.videoWidth;\n\t\t\t\tvideo.height = video.videoHeight;\n\t\t\t\tvideo.loop = true;\n\t\t\t\tvar texture = new goo.Texture();\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttexture.minFilter = 'BilinearNoMipMaps';\n\t\t\t\ttexture.setImage(video);\n\t\t\t\tctx.material = new goo.Material(goo.ShaderLib.textured);\tctx.material.uniforms.materialDiffuse = [1,1,0,1];\n\t\t\t\tctx.material.setTexture('DIFFUSE_MAP', texture);\n\t\t\t\tctx.skySphere = createSkySphere(ctx, ctx.material);\n\t\t\t\tctx.skySphere.addToWorld();\n\t\t\t\tctx.skySphere.setRotation(-Math.PI*0.5, Math.PI*1.0, 0);\n\t\t\t\ttexture.updateCallback = function () {\n\t\t\t\t\treturn !video.paused;\n\t\t\t\t};\n\t\t\t\tctx.texture = texture;\n\t\t\t\tctx.started = true;\n\t\t\t\tvideo.dataReady = true;\n\t\t\t}\n\t\t}\n\t};\n\tctx.listeners.touchend = ctx.listeners.mousedown;\n\tfor(var key in ctx.listeners){\n\t\tctx.domElement.addEventListener(key, ctx.listeners[key]);\n\t}\n    \n//         ctx.material = new goo.Material(goo.ShaderLib.textured);\n//         ctx.material.setTexture('DIFFUSE_MAP', args.texture1);\n//         ctx.skySphere = createSkySphere(ctx, ctx.material);\n//         ctx.skySphere.addToWorld();\n//         ctx.skySphere.setRotation(-Math.PI*0.5, 0, 0);\n// \t\tctx.video = ctx.material.getTexture('DIFFUSE_MAP').image;\n};\n\nvar cleanup = function (args, ctx) {\n\tif(ctx.skySphere !== undefined){\n        ctx.skySphere.removeFromWorld();\n    }\n\tfor(var key in ctx.listeners){\n\t\tctx.domElement.removeEventListener(key, ctx.listeners[key]);\n\t}\n};\n\nvar parameters = [{\n\tkey: 'videoUrl',\n\ttype: 'string',\n\t'default': ''\n},{\n\tkey: 'videoTexture',\n\ttype: 'texture'\n}];",
    "name": "Stream video script",
    "license": "CC0",
    "created": "2016-02-26T10:46:44.368Z",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2016-02-26T10:46:44.368Z",
    "id": "f262bb7418044b34ae6100230b7988c4.script"
  },
  "5de059f428574f899590bffcf9725071.entity": {
    "name": "Default Lights",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2015-07-27T15:45:29.194Z",
    "dataModelVersion": 2,
    "modified": "2015-07-27T15:45:29.194Z",
    "static": false,
    "components": {
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          0,
          0,
          0
        ],
        "children": {
          "c74e3e7e0a354362bb528f8a38d3dbff.entity": {
            "entityRef": "c74e3e7e0a354362bb528f8a38d3dbff.entity",
            "sortValue": 1
          },
          "843d5c34d3e6452fa3b44517b4b1488e.entity": {
            "entityRef": "843d5c34d3e6452fa3b44517b4b1488e.entity",
            "sortValue": 0
          }
        }
      }
    },
    "hidden": true,
    "id": "5de059f428574f899590bffcf9725071.entity"
  },
  "f758d1b3cb4f4a43b36de389c39550d0.script": {
    "body": "var setup = function(args, ctx, goo) {\n\tctx.touch = function() {\n\t\tif (!document.fullscreenElement) {\n\t\t\tdocument.documentElement.requestFullScreen();\n\t\t}\n\t};\n\tctx.domElement.addEventListener('touchstart', ctx.touch);\n};\nvar cleanup = function(args, ctx, goo) {\n\tctx.domElement.removeEventListener('touchstart', ctx.touch);\n};\n\n",
    "name": "Full screen",
    "license": "CC0",
    "created": "2015-06-25T11:28:03.738412+00:00",
    "deleted": false,
    "dataModelVersion": 2,
    "modified": "2015-06-25T11:28:05.451665+00:00",
    "dependencies": {},
    "id": "f758d1b3cb4f4a43b36de389c39550d0.script"
  },
  "1357bc80a1434a92bd41040591f474f2.entity": {
    "name": "Box",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2016-02-22T14:26:02.843Z",
    "dataModelVersion": 2,
    "modified": "2016-02-22T14:26:02.843Z",
    "static": false,
    "components": {
      "meshData": {
        "shape": "Box",
        "shapeOptions": {
          "textureMode": "Unfolded"
        }
      },
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          0,
          0,
          0
        ]
      },
      "meshRenderer": {
        "receiveShadows": true,
        "materials": {
          "92aca09436674360863731d38f23827a.material": {
            "materialRef": "92aca09436674360863731d38f23827a.material",
            "sortValue": 0
          }
        },
        "reflectable": true,
        "cullMode": "Dynamic",
        "castShadows": true
      },
      "script": {
        "scripts": {
          "a64bbd1698ba4d06b7802fa26f9febca.scriptinstance": {
            "id": "a64bbd1698ba4d06b7802fa26f9febca.scriptinstance",
            "name": "Instance of video_loader",
            "scriptRef": "107c4dcd5e1c48e1989dd9086aafed2a.script",
            "sortValue": 0,
            "options": {
              "texture2": {
                "enabled": true
              },
              "texture1": {
                "enabled": true
              },
              "enabled": false,
              "listenToStop": "stop",
              "listenToStart": "start"
            }
          }
        }
      }
    },
    "hidden": true,
    "id": "1357bc80a1434a92bd41040591f474f2.entity"
  },
  "763dc89e7b4649bea068cff5bd7797e4.entity": {
    "name": "VRDescription",
    "license": "CC0",
    "tags": {},
    "deleted": false,
    "created": "2016-02-24T09:01:44.626Z",
    "dataModelVersion": 2,
    "modified": "2016-02-24T09:01:44.626Z",
    "static": false,
    "components": {
      "html": {
        "imageRefs": {},
        "useTransformComponent": true,
        "innerHtml": "<div style=\"width:200px;\">\n<p style=\"font-size:12px;padding:4px;margin:0;border-radius:3px; font-family:roboto, helvetica, sans-serif; color:white\">\n\t<b>VR CAMERA<hr style=\"margin-left:4px; width:180px\"></b><p style=\"font-size:12px;padding:4px;margin:0;border-radius:3px; font-family:roboto, helvetica, sans-serif; color:white\">\n\tThe VR Camera consists of three different scripts working together as one. Open up the Scripts tab to view the settings. <br><br>\n\tVR Render Script is the renderer, dividing the screen in two segments that are essential for a VR experience. The \"Boost 3D Effect\" slider decides the distance between the \"eyes\". In general, upping the number gives a more accentuated 3D experience.<br><br>The Device Orientation script controls the camera movement. It taps in on the gyroscope of your mobile. If you uncheck the Absolute checkbox, the camera position will adjust to your device's starting position. The Lerp controls how smoothly the camera will follow your gyro, with 1 being the camera following your movements very precise.<br><br>Full Screen gets rid of the browser interface, which could otherwise distract or in some cases destroy the VR experience.<br><br><b>Note:</b> don't forget to set the VR camera as the main camera, and have post effects on. To toggle the post effects on and off, click the wand icon above the Create viewport, or press 3 on your keyboard.<br><br>To hide this message, please expand the VR Camera entity in the hierarchy, and press the eye icon next to \"VRDescription\".\n\t\n\t\n</p>\n</div>"
      },
      "transform": {
        "rotation": [
          0,
          0,
          0
        ],
        "scale": [
          1,
          1,
          1
        ],
        "translation": [
          -0.8148342370986938,
          0.28002703189849854,
          0
        ]
      }
    },
    "hidden": true,
    "id": "763dc89e7b4649bea068cff5bd7797e4.entity"
  },
  "4cfc09f9b76a4f4cad4a6032cdf0744a.material": {
    "flat": true,
    "cullState": {
      "frontFace": "CCW",
      "enabled": true,
      "cullFace": "Back"
    },
    "uniforms": {
      "opacity": {
        "enabled": false,
        "value": 1
      },
      "refractivity": {
        "enabled": false,
        "value": 0
      },
      "materialAmbient": {
        "enabled": true,
        "value": [
          0.3041666666666667,
          1,
          0.6981311274509803,
          1
        ]
      },
      "materialSpecular": {
        "enabled": true,
        "value": [
          0.6,
          0.6,
          0.6,
          1
        ]
      },
      "fresnel": {
        "enabled": true,
        "value": 0.5
      },
      "reflectivity": {
        "enabled": true,
        "value": 0.6
      },
      "materialSpecularPower": {
        "enabled": true,
        "value": 64
      },
      "materialDiffuse": {
        "enabled": true,
        "value": [
          0.8,
          0.8,
          0.8,
          1
        ]
      },
      "vertexColorAmount": {
        "enabled": true,
        "value": 1
      },
      "materialEmissive": {
        "enabled": true,
        "value": [
          0,
          0,
          0,
          1
        ]
      },
      "discardThreshold": {
        "enabled": true,
        "value": 0.1
      },
      "normalMultiplier": {
        "enabled": true,
        "value": 1
      },
      "etaRatio": {
        "enabled": true,
        "value": -0.5
      },
      "reflectionType": 0,
      "wrapSettings": {
        "enabled": true,
        "value": [
          0,
          0
        ]
      }
    },
    "name": "Default Material 3",
    "license": "CC0",
    "created": "2016-02-26T15:46:13.823Z",
    "deleted": false,
    "id": "4cfc09f9b76a4f4cad4a6032cdf0744a.material",
    "wireframe": false,
    "dataModelVersion": 2,
    "blendState": {
      "blendSrc": "SrcAlphaFactor",
      "blendDst": "OneMinusSrcAlphaFactor",
      "blendEquation": "AddEquation",
      "blending": "NoBlending"
    },
    "modified": "2016-02-26T15:46:13.823Z",
    "dualTransparency": false,
    "depthState": {
      "write": true,
      "enabled": true
    },
    "shaderRef": "GOO_ENGINE_SHADERS/uber",
    "texturesMapping": {},
    "renderQueue": -1
  }
}